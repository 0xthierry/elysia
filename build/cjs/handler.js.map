{"version":3,"sources":["../../src/handler.ts"],"sourcesContent":["import { validate } from './index'\nimport { concatArrayObject, isPromise, mergeHook, parseHeader } from './utils'\n\nimport type { JSONSchema } from 'fluent-json-schema'\nimport type { ParsedUrlQuery } from 'querystring'\n\nimport type {\n    Hook,\n    Handler,\n    TypedRoute,\n    ParsedRequest,\n    KingWorldInstance,\n    RegisterHook,\n    ComposedHandler\n} from './types'\n\nconst jsonHeader = Object.freeze({\n    headers: {\n        'Content-Type': 'application/json'\n    }\n})\n\nexport const composePreHandler = async <\n    Instance extends KingWorldInstance = KingWorldInstance\n>(\n    handlers: Handler<any, Instance>[],\n    request: ParsedRequest & Instance['Request'],\n    store: Instance['Store']\n) => {\n    for (const preHandler of handlers) {\n        let response = preHandler(request, store)\n        response = isPromise(response) ? await response : response\n\n        if (response)\n            switch (typeof response) {\n                case 'string':\n                    return new Response(response, {\n                        headers: request.responseHeader\n                    })\n\n                case 'object':\n                    try {\n                        return new Response(\n                            JSON.stringify(response),\n                            Object.assign(jsonHeader, {\n                                headers: request.responseHeader\n                            })\n                        )\n                    } catch (error) {\n                        throw new error()\n                    }\n\n                case 'function':\n                    const res = response as Response\n\n                    for (const [key, value] of Object.entries(\n                        request.responseHeader\n                    ))\n                        res.headers.append(key, value)\n\n                    return res\n\n                case 'number':\n                case 'boolean':\n                    return new Response(response.toString(), {\n                        headers: request.responseHeader\n                    })\n\n                default:\n                    break\n            }\n    }\n}\n\n// Currying to merge hook\nexport const composeHandler =\n    (handler: Handler<any, any>, hook: Hook<any>): ComposedHandler => [handler, hook]\n"],"names":["composePreHandler","composeHandler","jsonHeader","Object","freeze","headers","handlers","request","store","preHandler","response","isPromise","Response","responseHeader","JSON","stringify","assign","error","res","key","value","entries","append","toString","handler","hook"],"mappings":"AAAA,gKAsBaA,iBAAiB,KAAjBA,CAAiB,CAqDjBC,cAAc,KAAdA,CAAc,mBA1E0C,SAAS,EAexEC,CAAU,CAAGC,MAAM,CAACC,MAAM,CAAC,CAC7BC,OAAO,CAAE,CACL,cAAc,CAAE,kBAAkB,CACrC,CACJ,CAAC,CAEWL,CAAiB,CAAG,MAG7BM,CAAkC,CAClCC,CAA4C,CAC5CC,CAAwB,GACvB,CACD,IAAK,IAAMC,CAAU,IAAIH,CAAQ,CAAE,CAC/B,IAAII,CAAQ,CAAGD,CAAU,CAACF,CAAO,CAAEC,CAAK,CAAC,AAGzC,IAFAE,CAAQ,CAAGC,GAAAA,CAAS,UAAA,EAACD,CAAQ,CAAC,CAAG,MAAMA,CAAQ,CAAGA,CAAQ,CAGtD,OAAQ,OAAOA,CAAQ,EACnB,IAAK,QAAQ,CACT,OAAO,IAAIE,QAAQ,CAACF,CAAQ,CAAE,CAC1BL,OAAO,CAAEE,CAAO,CAACM,cAAc,CAClC,CAAC,AAEN,KAAK,QAAQ,CACT,GAAI,CACA,OAAO,IAAID,QAAQ,CACfE,IAAI,CAACC,SAAS,CAACL,CAAQ,CAAC,CACxBP,MAAM,CAACa,MAAM,CAACd,CAAU,CAAE,CACtBG,OAAO,CAAEE,CAAO,CAACM,cAAc,CAClC,CAAC,CACL,CACJ,AAAC,MAAOI,CAAK,CAAE,CACZ,MAAM,IAAIA,CAAK,AAAE,CACpB,AAEL,IAAK,UAAU,CACX,IAAMC,CAAG,CAAGR,CAAQ,AAAY,AAEhC,KAAK,GAAM,CAACS,CAAG,CAAEC,CAAK,CAAC,GAAIjB,MAAM,CAACkB,OAAO,CACrCd,CAAO,CAACM,cAAc,CACzB,CACGK,CAAG,CAACb,OAAO,CAACiB,MAAM,CAACH,CAAG,CAAEC,CAAK,CAAC,AAElC,QAAOF,CAAG,AAEd,KAAK,QAAQ,CAAC,AACd,IAAK,SAAS,CACV,OAAO,IAAIN,QAAQ,CAACF,CAAQ,CAACa,QAAQ,EAAE,CAAE,CACrClB,OAAO,CAAEE,CAAO,CAACM,cAAc,CAClC,CAAC,CAIT,CACR,CACJ,CAGYZ,CAAc,CACvB,CAACuB,CAA0B,CAAEC,CAAe,GAAsB,CAACD,CAAO,CAAEC,CAAI,CAAC"}